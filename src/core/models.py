from django.db import models

# Used for image resizing
from stdimage.models import StdImageField

# To indicate which site a record belongs to
from django.urls import reverse
from django.forms import ModelForm
from django.conf import settings
from markdown import markdown
from tinymce import HTMLField
import re
from unidecode import unidecode
from django.utils.text import slugify

from django.contrib.auth.models import User
from django.contrib.auth import get_user_model
User = get_user_model()

# To sanitize user input
import bleach
from django.utils.safestring import mark_safe

# To get the geometry fields
from django.contrib.gis.db import models

# To record the points for gps spreadsheets
from django.contrib.gis.geos import Point

# To be able to set an UUID
import uuid

# To be able to call just the filename in the file field
# Maybe move to def filename @property?
import os

# For youtube url parsing
from urllib.parse import urlparse, parse_qs

from django.utils import timezone
import pytz

# To get the total number of points
from django.db.models import Sum

# To get recently registered students in the course
import datetime

# To add a timestamp if needed to duplicated slugs
import time

import pandas as pd
import numpy as np

# To create the sample shapefile images
import geopandas
import contextily as ctx

from django.template.defaultfilters import filesizeformat
from django.db.models import Q

# For the regular extpression replacement in Data Articles
import re

# For our shapefile work
from django.contrib.gis.gdal import DataSource, OGRGeometry
from django.contrib.gis.gdal.srs import (AxisOrder, CoordTransform, SpatialReference)

# For the signals we use to update reference spaces when new pics are uploaded
from django.db.models.signals import post_save
from django.dispatch import receiver

def get_date_range(start, end, months_only=False):

    if start and not end and months_only:
        return "Since " + start.strftime("%b %Y")
        
    elif start and not end:
        return "Start date: " + start.strftime("%b %d, %Y")
        
    if not start or not end:
        return None

    start_date = start.strftime("%b %Y") if months_only else start.strftime("%b %d, %Y")
    start_time = "00:00" if months_only else start.strftime("%H:%M")
    end_date = end.strftime("%b %Y") if months_only else end.strftime("%b %d, %Y")
    end_time = "00:00" if months_only else end.strftime("%H:%M")

    if start_date == end_date:
        if months_only:
            return start_date
        elif start_time == "00:00" and end_time == "00:00":
            return start_date
        elif start_time == end_time:
            return start.strftime("%b %d, %Y %H:%M")
        else:
            return start_date + " " + start_time + " - " + end_time
    else:
        if start.strftime("%Y%m") == end.strftime("%Y%m"):
            return start.strftime("%b") + " " + start.strftime("%d") + " - " + end.strftime("%d") + ", " + start.strftime("%Y")
        elif start_time != "00:00" and end_time != "00:00":
            return start.strftime("%b %d, %Y %H:%M") + " - " + end.strftime("%b %d, %Y %H:%M")
        elif start.strftime("%Y") == end.strftime("%Y"):
            if months_only:
                return start.strftime("%b") + " - " + end_date
            else:
                return start.strftime("%b %d") + " - " + end_date
        else:
            return start_date + " - " + end_date

# By default we really only want to see those records that are both public and not deleted
class PublicActiveRecordManager(models.Manager):
    def get_queryset(self):
        return super().get_queryset().filter(is_deleted=False, is_public=True)

# This returns those records that are private (a check around ownership needs to take place in the codebase)
# and that are not deleted
class PrivateRecordManager(models.Manager):
    def get_queryset(self):
        return super().get_queryset().filter(is_deleted=False)

class Tag(models.Model):
    name = models.CharField(max_length=255)
    description = models.TextField(null=True, blank=True)
    description_html = models.TextField(null=True, blank=True, help_text="Do not edit... auto-generated by the system")
    parent_tag = models.ForeignKey("self", on_delete=models.CASCADE, null=True, blank=True, related_name="children")
    hidden = models.BooleanField(db_index=True, default=False, help_text="Mark if tag is superseded/not yet approved/deactivated")
    include_in_glossary = models.BooleanField(db_index=True, default=False)
    belongs_to = models.ForeignKey("Record", on_delete=models.CASCADE, null=True, blank=True)
    is_deleted = models.BooleanField(default=False, db_index=True)
    is_public = models.BooleanField(default=True, db_index=True)
    icon = models.CharField(max_length=50, null=True, blank=True, help_text="Only include the icon name, not fa- classes --- see https://fontawesome.com/icons?d=gallery")
    color = models.CharField(max_length=30, null=True, blank=True)
    slug = models.SlugField(max_length=50, unique=True, blank=True, null=True)

    def __str__(self):
        return self.name

    def get_description(self):
        # The description_html field is already sanitized, according to the settings (see the save() function below)
        # So when we retrieve the html description we can trust this is safe, and will mark it as such
        # We avoid using |safe in templates -- to centralize the effort to sanitize input
        if self.description:
            return mark_safe(self.description_html)
        else:
            return ""

    def get_name_after_colon(self):
        # For some tags, we have a long name like:
        # Layer 1: Infrastructure
        # And we want an easy way to just get "Infrastructure" returned
        try:
            string = self.name
            return string.split(":")[1]
        except:
            return self.name

    def get_name_after_period(self):
        # For some tags, we have a long name like:
        # 1.1. City boundaries
        # And we want an easy way to just get "City boundaries" returned
        try:
            string = self.name
            return string.split(".")[-1]
        except:
            return self.name

    def save(self, *args, **kwargs):
        if not self.description:
            self.description_html = None
        else:
            self.description_html = markdown(self.description)
        super().save(*args, **kwargs)

    @property
    def shortcode(self):
        "Returns abbreviation -- text between parenthesis -- if there is any"
        if "(" in self.name:
            s = self.name
            return s[s.find("(")+1:s.find(")")]
        else:
            return self.name

    @property
    def fullname(self):
        "Returns full name without abbreviation -- text between parenthesis -- if there is any"
        if "(" in self.name:
            s = self.name
            return s[0:s.find("(")-1]
        else:
            return self.name

    class Meta:
        ordering = ["name"]

    objects = PublicActiveRecordManager()
    objects_unfiltered = models.Manager()
    objects_include_private = PrivateRecordManager()

class Record(models.Model):
    name = models.CharField(max_length=255)
    description = models.TextField(null=True, blank=True)
    description_html = models.TextField(null=True, blank=True, help_text="Do not edit... auto-generated by the system")
    image = StdImageField(upload_to="records", variations={"thumbnail": (480, 480), "large": (1280, 1024)}, blank=True, null=True)
    tags = models.ManyToManyField(Tag, blank=True)
    date_created = models.DateTimeField(auto_now_add=True)

    spaces = models.ManyToManyField("ReferenceSpace", blank=True)
    sectors = models.ManyToManyField("Sector", blank=True)
    subscribers = models.ManyToManyField("People", blank=True)
    materials = models.ManyToManyField("Material", blank=True)

    # We use soft deleted
    is_deleted = models.BooleanField(default=False, db_index=True)

    # Only public records are shown; non-public records are used for instance to manage records 
    # belonging to logged-in users only
    is_public = models.BooleanField(default=True, db_index=True)

    # These relationships are managed through separate tables, but they allow for prefetching to make 
    # the queries run much more efficiently
    child_of = models.ManyToManyField("self", through="RecordRelationship", through_fields=("record_child", "record_parent"), symmetrical=False, related_name="parent_of_child")
    parent_to = models.ManyToManyField("self", through="RecordRelationship", through_fields=("record_parent", "record_child"), symmetrical=False, related_name="child_of_parent")

    # We are going to delete this post-launch
    old_id = models.IntegerField(null=True, blank=True, db_index=True, help_text="Only used for the migration between old and new structure")

    meta_data = models.JSONField(null=True, blank=True)

    def __str__(self):
        return self.name

    def get_absolute_url(self):
        if hasattr(self, "dataset"):
            url = reverse("data:dataset", args=[self.id])
        elif hasattr(self, "libraryitem"):
            url = reverse("library:item", args=[self.id])
        elif hasattr(self, "news"):
            url = reverse("core:news", args=[self.news.slug])
        elif hasattr(self, "event"):
            url = reverse("core:event", args=[self.event.slug])
        elif hasattr(self, "video"):
            url = reverse("multimedia:video", args=[self.id])
        elif hasattr(self, "course"):
            url = reverse("education:course", args=[self.course.slug])
        elif hasattr(self, "project"):
            url = self.project.get_website()
        else:
            return None
        first_chars = url[:5]
        if first_chars == "/http":
            url = url[1:]
        return url

    def get_methodologies(self):
        self.tags.filter(parent_tag__id=318)

    def get_markdown_description(self):
        return markdown(self.description) if self.description else None

    def authors(self):
        return People.objects.filter(parent_list__record_child=self, parent_list__relationship__id=4)

    def funders(self):
        return Record.objects.filter(parent_list__record_child=self, parent_list__relationship__id=5)

    def author(self):
        try:
            return People.objects.filter(parent_list__record_child=self, parent_list__relationship__id=4)[0]
        except:
            return None

    def get_description(self):
        # The description_html field is already sanitized, according to the settings (see the save() function below)
        # So when we retrieve the html description we can trust this is safe, and will mark it as such
        # We avoid using |safe in templates -- to centralize the effort to sanitize input
        if self.description:
            return mark_safe(self.description_html)
        else:
            return ""

    def save(self, *args, **kwargs):
        if not self.description:
            self.description_html = None
        elif self.meta_data and "format" in self.meta_data and self.meta_data["format"] != "markdown":
            if self.meta_data["format"] == "markdown_html":
                # Here it wouldn't hurt to apply bleach and take out unnecessary tags
                self.description_html = markdown(self.description)
            elif self.meta_data["format"] == "html":
                # Here it wouldn't hurt to apply bleach and take out unnecessary tags
                self.description_html = self.description
        else:
            self.description_html = markdown(bleach.clean(self.description))
            if hasattr(self, "dataarticle"):
                # For data articles we have a special syntax that converts things like [@3893] to a link, or [#3983] to an iframe

                p = re.compile("\[#(\d*)\]")
                self.description_html = p.sub(r'<iframe class="libraryitem card" src="/library/preview/\1/" onload="resizeIframe(this)"></iframe>', self.description_html)

                p = re.compile("\[@(\d*)\]")
                # For local testing, add /data/ to src=
                self.description_html = p.sub(r'<sup>[<a data-id="\1" href="/library/\1/">source</a>]</sup>', self.description_html)

            else:
                # In normal Markdown convention, a single newline will NOT be converted to <br>
                # However this is not how regular textareas work, and people are expecting this to work
                # so we add these <br>s. Ideally we would avoid <p>hello</p><br><p>newline</p> but 
                # for now that's the additional consequence -- doesn't seem to be a really visible impact anyways
                self.description_html = self.description_html.replace("\n", "<br>")
        super().save(*args, **kwargs)

    objects = PublicActiveRecordManager()
    objects_unfiltered = models.Manager()
    objects_include_private = PrivateRecordManager()

def upload_directory(instance, filename):
    # file will be uploaded to MEDIA_ROOT/uuid/<filename>
    directory = "uploads/"
    if hasattr(instance, "attached_to"):
        parent = instance.attached_to
    elif hasattr(instance, "attached"):
        parent = instance.attached
    else:
        parent = instance
    object_type = parent.__class__.__name__
    object_type = object_type.lower()
    directory += object_type + "/"
    if object_type == "libraryitem":
        sub_directory = parent.type.name
        sub_directory = sub_directory.lower()
        directory += sub_directory + "/"
    try:
        if parent.meta_data and "uuid" in parent.meta_data:
            directory += parent.meta_data["uuid"] + "/"
    except:
        pass
    return directory + filename

class Language(models.Model):
    name = models.CharField(max_length=255)
    def __str__(self):
        return self.name

class Document(Record):
    file = models.FileField(null=True, blank=True, upload_to=upload_directory, max_length=255)
    attached_to = models.ForeignKey(Record, on_delete=models.CASCADE, null=True, blank=True, related_name="attachments")

    objects = PublicActiveRecordManager()
    objects_unfiltered = models.Manager()
    objects_include_private = PrivateRecordManager()

    def get_size(self):
        file = self.file if self.file else self.image
        try:
            return filesizeformat(file.size) if file else None
        except:
            return 0

    def get_url(self):
        return self.file.url if self.file else self.image.url

class ProjectType(models.Model):
    name = models.CharField(max_length=255)
    icon = models.CharField(max_length=50, help_text="Only include the icon name, not fa- classes --- see https://fontawesome.com/icons?d=gallery")

    def __str__(self):
        return self.name

class Project(Record):
    type = models.ForeignKey(ProjectType, on_delete=models.CASCADE, null=True, blank=True)
    contributor_page = HTMLField(null=True, blank=True)
    support_page = HTMLField(null=True, blank=True)
    start_date = models.DateField(blank=True, null=True)
    end_date = models.DateField(blank=True, null=True)
    STATUS = (
        ("planned", "Planned"),
        ("ongoing", "Ongoing"),
        ("finished", "Finished"),
        ("cancelled", "Cancelled"),
    )
    status = models.CharField(max_length=20, choices=STATUS, default="ongoing")
    has_subsite = models.BooleanField(default=False)
    is_data_project = models.BooleanField(default=False)
    slug = models.SlugField(max_length=50, unique=True, blank=True, null=True)
    url = models.URLField(max_length=255, null=True, blank=True)
    screenshot = StdImageField(upload_to="project_screenshots", variations={"thumbnail": (350, 350), "medium": (510, 510), "large": (1280, 1024)}, blank=True, null=True, help_text="1280x1024 is best - do not include browser tabs/menus")
    summary_sentence = models.CharField(max_length=255, null=True, blank=True, help_text="Describe the project in a single sentence")

    def get_slug(self):
        if self.slug:
            return self.slug
        else:
            return "core"

    def get_absolute_url(self):
        return reverse("core:project", args=[self.slug])

    def get_website(self, remove_local_slug=False):
        if settings.DEBUG and self.has_subsite:
            local_url = "http://0.0.0.0:8000/"
            if remove_local_slug:
                return local_url
            return local_url + self.slug + "/"
        elif self.url:
            return self.url
        elif self.has_subsite:
            return "/" + self.slug + "/"
        else:
            return reverse("core:project", args=[self.slug])

    def get_content(self):
        return markdown(self.description) if self.type == "markdown" else self.description

    def get_image(self):
        if self.image:
            return self.image
        elif self.design.logo:
            return self.design.logo
        else:
            return None

    class Meta:
        ordering = ["name"]

    def get_dates(self):
        return get_date_range(self.start_date, self.end_date)
    
    def get_dates_months(self):
        return get_date_range(self.start_date, self.end_date, True)

    objects = PublicActiveRecordManager()
    objects_unfiltered = models.Manager()
    objects_include_private = PrivateRecordManager()

class PublicProject(Record):
    full_name = models.CharField(max_length=255, null=True, blank=True)
    email = models.EmailField(null=True, blank=True)
    url = models.URLField(max_length=255, null=True, blank=True)
    target_finish_date = models.CharField(max_length=255, null=True, blank=True)
    start_date = models.DateField(blank=True, null=True)
    end_date = models.DateField(blank=True, null=True)
    STATUS = (
        ("planned", "Planned"),
        ("ongoing", "Ongoing"),
        ("finished", "Finished"),
        ("cancelled", "Cancelled"),
    )
    status = models.CharField(max_length=20, choices=STATUS, default="ongoing")
    TYPE = (
        ("thesis", "Thesis project"),
        ("research", "Research project"),
    )
    type = models.CharField(max_length=20, choices=TYPE, default="research")
    part_of_project = models.ForeignKey(Project, on_delete=models.CASCADE, null=True, blank=True)

    def get_dates(self):
        return get_date_range(self.start_date, self.end_date)
    
    def get_dates_months(self):
        return get_date_range(self.start_date, self.end_date, True)

    def get_absolute_url(self):
        return reverse("community:project", args=[self.id])

    objects = PublicActiveRecordManager()
    objects_unfiltered = models.Manager()
    objects_include_private = PrivateRecordManager()

class News(Record):
    date = models.DateField()
    slug = models.SlugField(max_length=255)
    projects = models.ManyToManyField(Project)
    include_in_timeline = models.BooleanField(default=False)

    def get_absolute_url(self):
        if self.projects.count() > 0:
            p = self.projects.all()[0]
            if p.has_subsite:
                return p.get_website() + "news/" + self.slug + "/"
            else:
                return reverse("community:news", args=[self.slug])
        else:
            return reverse("community:news", args=[self.slug])

    def authors(self):
        return People.objects.filter(parent_list__record_child=self, parent_list__relationship__id=4)

    def save(self, *args, **kwargs):
        self.slug = slugify(unidecode(self.name))
        super().save(*args, **kwargs)

    class Meta:
        verbose_name_plural = "news"
        ordering = ["-date", "-id"]

    objects = PublicActiveRecordManager()
    objects_unfiltered = models.Manager()
    objects_include_private = PrivateRecordManager()

class Blog(Record):
    date = models.DateField()
    slug = models.SlugField(max_length=255)
    class Meta:
        ordering = ["-date", "-id"]
    def get_absolute_url(self):
        return reverse("blog", args=[self.id])
    def save(self, *args, **kwargs):
        self.slug = slugify(unidecode(self.name))
        super().save(*args, **kwargs)

    objects = PublicActiveRecordManager()
    objects_unfiltered = models.Manager()
    objects_include_private = PrivateRecordManager()

class NaceCode(models.Model):
    name = models.CharField(max_length=255)

    def __str__(self):
        return self.name

    class Meta:
        ordering = ["id"]

class Organization(Record):
    url = models.CharField(max_length=255, null=True, blank=True)
    twitter = models.CharField(max_length=255, null=True, blank=True)
    linkedin = models.CharField(max_length=255, null=True, blank=True)
    researchgate = models.CharField(max_length=255, null=True, blank=True)
    email = models.EmailField(null=True, blank=True)
    slug = models.SlugField(max_length=255)
    ORG_TYPE = (
        ("academic", "Research Institution"),
        ("universities", "Universities"),
        ("city_government", "City Government"),
        ("regional_government", "Regional Government"),
        ("national_government", "National Government"),
        ("statistical_agency", "Statistical Agency"),
        ("private_sector", "Private Sector"),
        ("publisher", "Publishers"),
        ("journal", "Journal"),
        ("society", "Academic Society"),
        ("ngo", "NGO"),
        ("funding_program", "Funding Programme"),
        ("other", "Other"),
    )
    type = models.CharField(max_length=20, choices=ORG_TYPE)
    updated_at = models.DateField(null=True, auto_now=True)

    def save(self, *args, **kwargs):
        self.slug = slugify(unidecode(self.name))
        if self.email:
            self.email=self.email.lower()
        if self.twitter:
            try:
                url = self.twitter
                if url[:4] == "http":
                    self.twitter = url.rsplit("/", 1)[-1]
                elif url[:1] == "@":
                    self.twitter = url[1:]
            except:
                pass
        super().save(*args, **kwargs)

    def get_absolute_url(self):
        return reverse("library:journal", args=[self.slug])

    def publications(self):
        # To get all the publications we'll get the LibraryItems that are a child
        # record that are linked to this organization (e.g. journal or publishing house) as a parent
        return LibraryItem.objects.select_related("type").filter(child_list__record_parent=self, child_list__relationship__id=2)

    objects = PublicActiveRecordManager()
    objects_unfiltered = models.Manager()
    objects_include_private = PrivateRecordManager()

    class Meta:
        ordering = ["name"]

# This defines the relationships that may exist between users and records, or between records
# For instance authors, admins, employee, funder
class Relationship(models.Model):
    name = models.CharField(max_length=255)
    label = models.CharField(max_length=255)
    slug = models.SlugField(max_length=20, db_index=True, unique=True, blank=True, null=True, help_text="Should only be set for permissions, and should only be modified by the programming team")
    description = models.TextField(null=True, blank=True)
    is_permission = models.BooleanField(default=False, help_text="Mark if this relationship is about giving people permissions in the system")
    def __str__(self):
        return self.label

# This defines a particular relationship between two records.
# For instance: Record 100 (company AA) has the relationship "Funder" of Record 104 (Project BB)
# It will always be in the form of RECORD_PARENT is RELATIONSHIP of RECORD_CHILD
# Wiley is the publisher of the JIE. Wiley = record_parent; JIE = record_child
# Fulano is the author of Paper A. Fulano = record_parent; Paper A = record_child 
class RecordRelationship(models.Model):
    record_parent = models.ForeignKey(Record, on_delete=models.CASCADE, related_name="parent_list")
    relationship = models.ForeignKey(Relationship, on_delete=models.CASCADE)
    record_child = models.ForeignKey(Record, on_delete=models.CASCADE, related_name="child_list")
    date_created = models.DateTimeField(auto_now_add=True, null=True, blank=True)

    def __str__(self):
        return str(self.record_parent) + ' ' + str(self.relationship.label) + ' ' + str(self.record_child)

    class Meta:
        verbose_name_plural = "relationship manager"
        verbose_name = "relationship manager"
        unique_together = ["record_parent", "relationship", "record_child"]

class SocialMediaPlatform(models.Model):
    name = models.CharField(max_length=255)
    icon = models.CharField(max_length=30)

    def __str__(self):
        return self.name

class SocialMedia(models.Model):
    name = models.CharField(max_length=255)
    record = models.ForeignKey(Record, on_delete=models.CASCADE, null=True, blank=True)
    STATUS = [
        ("draft", "Draft"),
        ("discarded", "Discarded"),
        ("ready", "Ready for publication"),
        ("published", "Published"),
    ]
    status = models.CharField(max_length=20, blank=True, null=True, choices=STATUS, default="draft")
    date = models.DateTimeField(null=True, blank=True)
    description = models.TextField(null=True, blank=True)
    response = models.TextField(null=True, blank=True)
    image = StdImageField(upload_to="socialmedia", variations={"thumbnail": (480, 480), "large": (1280, 1024)}, blank=True, null=True)
    campaign = models.ForeignKey(Tag, on_delete=models.CASCADE, limit_choices_to={"parent_tag_id": 927})
    platforms = models.ManyToManyField(SocialMediaPlatform)

    def __str__(self):
        return self.name

class Event(Record):
    EVENT_TYPE = [
        ("conference", "Conference"),
        ("hackathon", "Hackathon"),
        ("workshop", "Workshop"),
        ("seminar", "Seminar"),
        ("summerschool", "Summer School"),
        ("other", "Other"),
        ("training_outreach", "Training and Outreach"),
    ]
    type = models.CharField(max_length=20, blank=True, null=True, choices=EVENT_TYPE)
    url = models.URLField(max_length=255, null=True, blank=True)
    location = models.CharField(max_length=255, null=True, blank=True)
    start_date = models.DateTimeField(null=True, blank=True)
    end_date = models.DateTimeField(null=True, blank=True)
    slug = models.SlugField(max_length=255)
    projects = models.ManyToManyField(Project)

    class Meta:
        ordering = ["-start_date", "-id"]

    def get_absolute_url(self):
        if self.projects.count() > 0:
            return self.projects.all()[0].get_website() + "events/" + str(self.id) + "/" + self.slug + "/"
        else:
            return reverse("community:event", args=[self.id, self.slug])

    def get_dates(self):
        return get_date_range(self.start_date, self.end_date)

    def save(self, *args, **kwargs):
        self.slug = slugify(unidecode(self.name))
        super().save(*args, **kwargs)

    def get_status(self):
        try:
            today = timezone.now()
            if self.end_date < today:
                return "finished"
            elif self.start_date <= today and self.end_date >= today:
                return "active"
            else:
                return "upcoming"
        except:
            return "upcoming"

    objects = PublicActiveRecordManager()
    objects_unfiltered = models.Manager()
    objects_include_private = PrivateRecordManager()

class People(Record):
    firstname = models.CharField(max_length=255, null=True, blank=True)
    lastname = models.CharField(max_length=255, null=True, blank=True)
    affiliation = models.CharField(max_length=255,null=True, blank=True)
    email = models.EmailField(max_length=255, null=True, blank=True)
    email_public = models.BooleanField(default=False)
    website = models.CharField(max_length=255, null=True, blank=True)
    twitter = models.CharField(max_length=255, null=True, blank=True)
    google_scholar = models.CharField(max_length=255, null=True, blank=True)
    orcid = models.CharField(max_length=255, null=True, blank=True)
    researchgate = models.CharField(max_length=255, null=True, blank=True)
    linkedin = models.CharField(max_length=255, null=True, blank=True)
    research_interests = models.TextField(null=True, blank=True)
    PEOPLE_STATUS = (
        ("active", "Active"),
        ("retired", "Retired"),
        ("deceased", "Deceased"),
        ("inactive", "Inactive"),
        ("pending", "Pending Review"),
    )
    status = models.CharField(max_length=8, choices=PEOPLE_STATUS, default="active")
    user = models.OneToOneField(User, null=True, blank=True, on_delete=models.CASCADE)
    badges = models.ManyToManyField("Badge", blank=True)

    def __str__(self):
        return self.name

    def get_absolute_url(self):
        return reverse("community:person", args=[self.id])

    def points(self):
        points = Work.objects_unfiltered.filter(assigned_to=self, status=Work.WorkStatus.COMPLETED).aggregate(total=Sum("workactivity__points"))
        return points["total"]

    def avatar(self):
        if self.image and self.image != "":
            return mark_safe('<img class="avatar" src="' + self.image.thumbnail.url + '" alt="' + self.name + '" title="' + self.name + '">')
        else:
            return mark_safe('<div title="' + self.name + '" class="avatar letter">' + self.name[:1] + '</div>')

    def get_photo(self):
        if self.image:
            return self.image
        else:
            photo = Photo.objects.get(pk=33476)
            return photo.image

    class Meta:
        verbose_name_plural = "people"
        ordering = ["name"]

    def save(self, *args, **kwargs):
        if self.email:
            self.email=self.email.lower()
        if self.twitter:
            try:
                url = self.twitter
                if url[:4] == "http":
                    self.twitter = url.rsplit("/", 1)[-1]
                elif url[:1] == "@":
                    self.twitter = url[1:]
            except:
                pass
        super(People, self).save(*args, **kwargs)

    objects = PublicActiveRecordManager()
    objects_unfiltered = models.Manager()
    objects_include_private = PrivateRecordManager()

# We use this to keep a version history of records (which is done for some, not all)
# We save the record name/title and the description, which allows us to go 
# back in time when needed / see a revision history
# It also allows for people to draft a NEW version and review this first before going live
class RecordHistory(models.Model):

    class Status(models.IntegerChoices):
        HISTORIC = 1, "Historic version"
        DRAFT = 2, "New draft version (unapproved)"
        REJECTED = 3, "Rejected version"

    status = models.IntegerField(choices=Status.choices, db_index=True)
    name = models.CharField(max_length=255)
    description = models.TextField(null=True, blank=True)
    date_created = models.DateTimeField(auto_now_add=True)
    record = models.ForeignKey(Record, on_delete=models.CASCADE, related_name="history")
    people = models.ForeignKey(People, on_delete=models.CASCADE, related_name="record_history")

    class Meta:
        ordering = ["-id"]

class Webpage(Record):
    TYPE = [
        ("html", "HTML"),
        ("markdown", "Markdown"),
        ("markdown_html", "Markdown and HTML"),
    ]
    type = models.CharField(max_length=13, choices=TYPE, default="markdown")
    slug = models.CharField(db_index=True, max_length=100)
    part_of_project = models.ForeignKey(Project, on_delete=models.CASCADE, null=True, blank=True, related_name="webpages")

    objects = PublicActiveRecordManager()
    objects_unfiltered = models.Manager()
    objects_include_private = PrivateRecordManager()

    def get_absolute_url(self):
        return self.slug

    def get_content(self):
        if self.type == "markdown":
            return bleach.clean(markdown(self.description))
        elif self.type == "html":
            return self.description
        elif self.type == "markdown_html":
            return markdown(self.description)

    class Meta:
        constraints = [
            models.UniqueConstraint(fields=["part_of_project", "slug"], name="project_slug")
        ]
        ordering = ["name"]

class WebpageDesign(models.Model):
    webpage = models.OneToOneField(Record, on_delete=models.CASCADE, primary_key=True)
    HEADER = [
        ("inherit", "No custom header - use the project header"),
        ("full", "Full header with title and subtitle"),
        ("small", "Small header; menu only"),
        ("image", "Image underneath menu"),
    ]
    header = models.CharField(max_length=7, choices=HEADER, default="full")
    header_title = models.CharField(max_length=100, null=True, blank=True)
    header_subtitle = models.CharField(max_length=255, null=True, blank=True)
    header_image = StdImageField(upload_to="header_image", variations={"thumbnail": (480, 480), "large": (1280, 1024), "huge": (2560, 1440)}, blank=True, null=True)
    custom_css = models.TextField(null=True, blank=True)
    def __str__(self):
        return self.webpage.name

class ProjectDesign(models.Model):
    project = models.OneToOneField(Project, on_delete=models.CASCADE, primary_key=True, related_name="design")
    HEADER = [
        ("full", "Full header with title and subtitle"),
        ("small", "Small header; menu only"),
        ("image", "Image underneath menu"),
    ]
    header = models.CharField(max_length=6, choices=HEADER, default="full")
    HEADER_COLOR = [
        ("dark", "Dark background, light text"),
        ("light", "Light background, dark text"),
    ]
    header_color = models.CharField(max_length=6, choices=HEADER_COLOR, default="dark")
    logo = models.FileField(null=True, blank=True, upload_to="logos")
    custom_css = models.TextField(null=True, blank=True)
    back_link = models.BooleanField(default=True)
    show_footer_1 = models.BooleanField(default=True)
    show_footer_2 = models.BooleanField(default=True)
    show_footer_3 = models.BooleanField(default=True)
    content_footer_4 = models.TextField(null=True, blank=True)

    def __str__(self):
        return self.project.name

    def get_footer_4(self):
        if self.content_footer_4:
            return mark_safe(self.content_footer_4)
        else:
            return ""

class ForumTopic(Record):
    last_update = models.ForeignKey("Message", on_delete=models.SET_NULL, null=True, blank=True)
    part_of_project = models.ForeignKey(Project, on_delete=models.CASCADE, null=True, blank=True)
    parent = models.ForeignKey(Record, on_delete=models.CASCADE, null=True, blank=True, related_name="forum_topics")
    is_starred = models.BooleanField(default=False, null=True)
    parent_url = models.URLField(null=True, blank=True, db_index=True)

    def posters(self):
        return People.objects.filter(message_list__parent=self).distinct()

    def get_absolute_url(self):
        if self.parent_url:
            return self.parent_url
        else:
            return reverse("core:forum", args=[self.id])

    def get_full_url(self):
        # Sometimes we want to create a full URL, combining the 
        # project website with a path that /starts/with/a/slash
        # so in that case we want to ensure the https://project.com/ 
        # website doesn't end with a slash
        if self.parent_url:
            if not self.part_of_project:
                return self.parent_url
            else:
                project_site = self.part_of_project.get_website()
                last_char = project_site[-1]
                if last_char == "/":
                    project_site = project_site[:-1]
                return project_site + self.parent_url
        else:
            return reverse("core:forum", args=[self.id])

    class Meta:
        ordering = ["-is_starred", "-last_update__date_created"]

class Message(Record):
    parent = models.ForeignKey(Record, on_delete=models.CASCADE, null=True, blank=True, related_name="messages")
    posted_by = models.ForeignKey(People, on_delete=models.CASCADE, null=True, blank=True, related_name="message_list")

    def save(self, *args, **kwargs):
        super().save(*args, **kwargs)
        # If this is a forum or work-related message (most of them are) then we need to record
        # in the parent what the latest mesage is (this is for sorting, filtering etc)
        try:
            if hasattr(self.parent, "forumtopic"):
                parent = self.parent.forumtopic
            elif hasattr(self.parent, "work"):
                parent = self.parent.work
            if parent:
                check_last_update = Message.objects.filter(parent=self.parent).order_by("-date_created")
                if check_last_update:
                    parent.last_update = check_last_update[0]
                    parent.save()
        except Exception as e:
            pass

    def get_absolute_url(self):
        try:
            if hasattr(self.parent, "forumtopic"):
                return reverse("core:forum", args=[self.parent.id])
            elif hasattr(self.parent, "work"):
                return reverse("core:work_item", args=[self.parent.id])
            else:
                return None
        except:
            return None

    class Meta:
        ordering = ["date_created"]

    objects = PublicActiveRecordManager()
    objects_unfiltered = models.Manager()
    objects_include_private = PrivateRecordManager()

class License(models.Model):
    name = models.CharField(max_length=255)
    url = models.CharField(max_length=255, null=True, blank=True)
    
    def __str__(self):
        return self.name

    class Meta:
        ordering = ["name"]

class LibraryItemType(models.Model):
    name = models.CharField(max_length=255)
    icon = models.CharField(max_length=255, null=True, blank=True)
    GROUP = (
        ("academic", "Academic"),
        ("theses", "Theses"),
        ("reports", "Reports"),
        ("multimedia", "Multimedia"),
    )
    group = models.CharField(max_length=20, choices=GROUP, null=True, blank=True)

    def __str__(self):
        return self.name
    class Meta:
        ordering = ["name"]

class LibraryItem(Record):
    LANGUAGES = (
        ("EN", "English"),
        ("ES", "Spanish"),
        ("CH", "Chinese"),
        ("FR", "French"),
        ("GE", "German"),
        ("NL", "Dutch"),
        ("PT", "Portuguese"),
        ("CT", "Catalan"),
        ("OT", "Other"),
    )
    language = models.CharField(max_length=2, choices=LANGUAGES, default="EN", null=True, blank=True)
    title_original_language = models.CharField(max_length=255, blank=True, null=True)
    author_list = models.TextField(null=True, blank=True)
    author_citation = models.TextField(null=True, blank=True)
    bibtex_citation = models.TextField(null=True, blank=True)
    type = models.ForeignKey(LibraryItemType, on_delete=models.CASCADE)
    is_part_of = models.ForeignKey("self", on_delete=models.SET_NULL, null=True, blank=True, related_name="children")
    year = models.PositiveSmallIntegerField(null=True, blank=True)
    abstract_original_language = models.TextField(null=True, blank=True)
    date_added = models.DateTimeField(null=True, blank=True, auto_now_add=True)
    file = models.FileField(null=True, blank=True, upload_to="library")
    url = models.CharField(max_length=500, null=True, blank=True)
    file_url = models.URLField(null=True, blank=True)
    open_access = models.BooleanField(null=True, blank=True)
    doi = models.CharField(max_length=255, null=True, blank=True)
    isbn = models.CharField(max_length=255, null=True, blank=True)
    comments = models.TextField(null=True, blank=True)
    license = models.ForeignKey(License, on_delete=models.CASCADE, null=True, blank=True)
    geocodes = models.ManyToManyField("Geocode", blank=True)

    STATUS = (
        ("pending", "Pending"),
        ("active", "Active"),
        ("deleted", "Deleted"),
    )
    # We will delete this after we inserted appropriate work tickets
    status = models.CharField(max_length=8, choices=STATUS, db_index=True, null=True, blank=True, help_text="Old field, do not use")
    #processes = models.ManyToManyField("staf.Process", blank=True, limit_choices_to={"slug__isnull": False})
    #materials = models.ManyToManyField("staf.Material", blank=True)

    def __str__(self):
        return self.name if self.name else "Untitled " + self.type.name

    class Meta:
        ordering = ["-year", "name"]

    def get_absolute_url(self):
        if self.type_id == 31:
            # Videos are opened in the multimedia library
            return reverse("multimedia:video", args=[self.id])
        elif self.type_id == 33:
            # Data viz are opened in the multimedia library
            return reverse("multimedia:dataviz", args=[self.id])
        elif self.type_id == 24:
            # Podcasts are opened in the multimedia library
            return reverse("multimedia:podcast", args=[self.id])
        elif self.type_id == 10 or self.type_id == 40:
            # Datasets and shapefiles are opened in the data hub
            return reverse("data:dataset", args=[self.id])
        else:
            return reverse("library:item", args=[self.id])

    def get_canonical_website(self):
        if self.type_id == 31 or self.type_id == 33 or self.type_id == 24:
            return "https://multimedia.metabolismofcities.org"
        elif self.type_id == 10 or self.type_id == 40:
            return "https://data.metabolismofcities.org"
        else:
            return "https://library.metabolismofcities.org"

    def get_full_url(self):
        # Depending on which subsite we are on, the absolute url may
        # already or may not yet include the HTTP part, so here we try to 
        # make sure we always have the full URL
        url = self.get_absolute_url()
        first_chars = url[:4]
        if first_chars == "/htt":
            return url[1:]
        elif first_chars == "http":
            return url
        else:
            return self.get_canonical_website() + url

    def get_edit_link(self):
        if self.type_id == 31:
            # Videos are opened in the multimedia library
            return "/admin/core/video/" + str(self.id) + "/change/"
        else:
            return "/admin/core/libraryitem/" + str(self.id) + "/change/"

    def publisher(self):
        list = Organization.objects.filter(parent_list__record_child=self, parent_list__relationship__id=2)
        return list[0] if list else None

    def producer(self):
        list = Organization.objects.filter(parent_list__record_child=self, parent_list__relationship__id=3)
        return list[0] if list else None

    def uploader(self):
        list = People.objects.filter(parent_list__record_child=self, parent_list__relationship__id=11)
        return list[0] if list else None

    def processor(self):
        list = People.objects.filter(parent_list__record_child=self, parent_list__relationship__id=34)
        return list[0] if list else None

    # The 'author_list' part will be highly varied... some contain Firstname Lastname, Firstname Lastname 
    # others contain Lastname, Firstname and Lastname, Firstname
    # others contain Firstname Lastname; Firstname Lastname; etc.
    # This script tries to get the author_list ready for in-text citation (up to two authors; adding et al 
    # if there are more). 
    def get_author_citation(self):
        if self.author_citation:
            return self.author_citation
        elif self.author_list:
            author_array = []
            author_list = self.author_list
            if " and " in author_list:
                authors = author_list.split(" and ")
                for each in authors:
                    if "," in each:
                        lastname = each.split(",", 1)[0]
                    else:
                        lastname = each.rpartition(" ")[2]
                    author_array.append(lastname)
            elif ";" in author_list:
                authors = author_list.split(";")
                for each in authors:
                    if "," in each:
                        lastname = each.split(",", 1)[0]
                    else:
                        lastname = each.rpartition(" ")[2]
                    author_array.append(lastname)
            elif "," in author_list:
                authors = author_list.split(",")
                for each in authors:
                    lastname = each.rpartition(" ")[2]
                    author_array.append(lastname)
            else:
                # One option is to show JUST the lastname, but in practice it's more likely 
                # that this is the name of an entity like "City of Cape Town", so let's do the 
                # whole name instead
                # lastname = author_list.rpartition(" ")[2]
                author_array.append(author_list)
            if len(author_array) == 1:
                return author_array[0]
            elif len(author_array) == 2:
                return author_array[0] + " and " + author_array[1]
            elif len(author_array) > 2:
                return mark_safe(bleach.clean(author_array[0]) + " <em>et al.</em>")
            else:
                return ""
        else:
            return ""

    def get_full_citation(self):
        return mark_safe("<em>" + self.name + "</em>, " + self.get_author_citation() + ", " + str(self.year))
        
    def embed(self):
        if "ted" in self.url:
            try:
                url = self.url
                url = url.split("/")
                url = url[-1]
                return f'<iframe class="video-embed video-ted" src="https://embed.ted.com/talks/{url}" frameborder="0" scrolling="no" allowfullscreen></iframe>'
            except:
                return "<div class='alert alert-warning'>Embedded video unavailable. <a href='" + self.url + "'>Click here to view the video</a></div>"

    def get_size(self):
        try:
            return filesizeformat(self.file.size) if self.file else None
        except:
            return 0

    def get_shortname(self):
        if self.meta_data and "shortname" in self.meta_data:
            return self.meta_data["shortname"]
        else:
            return self.name

    @property
    def get_shapefile_size(self):
        try:
            file = self.attachments.get(file__iendswith=".shp")
            return file.file.size
        except:
            return 0

    @property
    def get_shapefile_plot(self):
        try:
            return settings.MEDIA_URL + self.meta_data["shapefile_plot"]
        except:
            return None

    @property
    def get_dataviz_properties(self):
        try:
            viz = self.dataviz.all()[0]
            viz = viz.meta_data["properties"]
        except:
            viz = {}
        return viz

    @property
    def is_map(self):
        if self.type.name == "Shapefile" or self.type.name == "GPS Coordinates":
            return True
        else:
            return False

    # Returns either 'point' if this contains points, 'polygon' if it contains other geometry, and 'unknown' if we can't tell
    # This can be used to decide for instance whether to show markers on a map or draw polygons
    # Note that we use the FIRST associated reference space, even though there may be many, and take that type, so we assume
    # that the entire map has the same type (a pretty safe assumption, would be weird if different)
    @property
    def get_map_type(self):
        try:
            one_space = self.imported_spaces.all()[0]
            if one_space.geometry.geom_type == "Point":
                return "point"
            else:
                return "polygon"
        except:
            return "unknown"
        
    # This takes the stocks or flows file and records it in the Data table
    # Note that I feel this 'try except' fest may be a bit of a loose canon and I am 
    # very open to people with better ideas on how to structure this and properly catch
    # errors.
    def convert_stocks_flows_data(self):
        error = False

        try:
            file_id = self.meta_data["processing"]["file"]
            file = self.get_spreadsheet(file_id)
            if file["error"]:
                error = file["error_message"]
        except:
            error = "We could not find/open this file."

        if not error:
            all = Data.objects.filter(source=self)
            all.delete()

            df = file["df"]
            column_count = len(df.columns)

            if column_count <= 5:
                type = "population"
            elif column_count <= 8:
                type = "stock"
            else:
                type= "flows"

            materials = {}
            units = {}
            spaces = {}
            times = {}
            items = []

            for row in df.itertuples():
                if not error:
                    try:
                        if type == "flows":
                            period = row[1]
                            start = row[2]
                            end = row[3]
                            material_name = row[4]
                            material_code = str(row[5])
                            material_code = material_code.strip()
                            quantity = row[6]
                            unit = row[7]
                            space = str(row[8])
                            space = space.strip()
                            comment = row[9]
                            try:
                                segment = row[10]
                            except:
                                segment = None
                        elif type == "stock":
                            period = row[1]
                            start = row[1]
                            end = None
                            material_name = row[2]
                            material_code = str(row[3])
                            material_code = material_code.strip()
                            quantity = row[4]
                            unit = row[5]
                            space = str(row[6])
                            space = space.strip()
                            comment = row[8]
                            try:
                                segment = row[9]
                            except:
                                segment = None
                        elif type == "population":
                            period = row[1]
                            start = row[1]
                            end = None
                            material_name = "People"
                            material_code = "EMP1.5.1"
                            unit = "item"
                            quantity = row[2]
                            space = str(row[3])
                            space = space.strip()
                            comment = row[4]
                            try:
                                segment = row[5]
                            except:
                                segment = None
                    except Exception as e:
                        error = f"We could not properly interpret all of the columns. Are you sure this is formatted correctly and contains the right data? This is the technical error that was returned by the system: {e}"
                        
                    if material_code not in materials:
                        try:
                            m = Material.objects.get(catalog_id=18998, code=material_code)
                            materials[material_code] = m
                        except:
                            error = f"We could not find the material/product with code: '{material_code}'"

                    if space not in spaces:
                        try:
                            source = self.meta_data["processing"]["source"]
                            s = ReferenceSpace.objects.get(source_id=source, name=space)
                            spaces[space] = s
                        except:
                            error = f"We could not find the space with the name: '{space}'"

                    if unit not in units:
                        try:
                            u = Unit.objects.filter(Q(symbol=unit)|Q(synonyms__contains=unit)).exclude(type=99)
                            units[unit] = u[0]
                        except:
                            error = f"We could not find the unit with the name: '{unit}'"

                    try:
                        if type == "flows":
                            start = start.strftime("%Y-%m-%d")
                            end = end.strftime("%Y-%m-%d")
                            full_string = str(start) + str(end)
                        elif type == "stock" or type == "population":
                            start = start.strftime("%Y-%m-%d")
                            end = None
                            full_string = str(start)
                            period = str(start)

                        if full_string not in times:
                            t = TimePeriod.objects.create(
                                start = start,
                                end = end,
                                name = period,
                            )
                            times[full_string] = t
                    except Exception as e:
                        error = f"We had an issue formatting your date(s) - this error came back: {e}"

                    if not error:
                        try:
                            items.append(Data(
                                unit = units[unit],
                                quantity = quantity,
                                material = materials[material_code],
                                material_name = material_name,
                                source = self,
                                origin_space = spaces[space],
                                comments = comment,
                                timeframe = times[full_string],
                                segment_name = segment,
                            ))
                        except Exception as e:
                            error = f"We were unable to add your item - this is the error that came back: {e} is invalid"

            if not error:
                try:
                    Data.objects.bulk_create(items)
                except Exception as e:
                    error = f"We were unable to save the records - this is the error that came back: {e}"

        self.meta_data["ready_for_processing"] = False
        if error:
            self.meta_data["processing_error"] = error
        else:
            self.meta_data["processed"] = True
            if "processing_error" in self.meta_data:
                self.meta_data.pop("processing_error")
            if "allow_deletion_data" in self.meta_data:
                self.meta_data.pop("allow_deletion_data")

        self.save()

    # This function converts the shapefile into ReferenceSpaces
    def convert_shapefile(self):

        check = ReferenceSpace.objects.filter(source=self)
        error = False

        if check:
            if self.meta_data.get("allow_deletion_spaces"):
                # only if this is flagged to allow for deletion will we allow it - otherwise we'll stop this process
                check.delete()
            else:
                error = "This file was already processed - we can not process it again"

        if self.type.id == 40 and not error: # Type = shapefile

            layer = self.get_gis_layer()
            fields = layer.fields
            total_count = layer.num_feat
            type = layer.geom_type.name
            if total_count > 1000 and not self.meta_data.get("skip_size_check"):
                error = "This file has too many objects. It needs to be verified by an administrator in order to be fully loaded into the system."
            else:
                count = 0
                for each in layer:
                    count += 1
                    meta_data = {}
                    
                    # We'll get all the properties and we store this in the meta data of the new object
                    for f in fields:
                        # We can't save datetime objects in json, so if it's a datetime then we convert to string
                        meta_data[f] = str(each.get(f)) if isinstance(each.get(f), datetime.date) else each.get(f)

                    name = str(each.get(self.meta_data["columns"]["name"]))

                    if type == "Point25D":
                        # This type has a "Z" geometry which needs to be changed to a 2-dimensional geometry
                        # See also https://stackoverflow.com/questions/35851577/strip-z-dimension-on-geodjango-force-2d-geometry
                        get_clone = each.geom.clone()
                        get_clone.coord_dim = 2
                        geo = get_clone
                    else:
                        geo = each.geom

                    # We use WGS 84 (4326) as coordinate reference system, so we gotta convert to that
                    # if it uses something else
                    if layer.srs.srid != 4326:
                        ct = CoordTransform(layer.srs, SpatialReference("WGS84"))
                        geo.transform(ct)
                    geo = geo.wkt

                    space = ReferenceSpace.objects.create(
                        name = name,
                        geometry = geo,
                        source = self,
                        meta_data = {"features": meta_data},
                    )

        elif self.type.id == 41 and not error: # Type = GPS coordinate spreadsheet

            spreadsheet = self.get_spreadsheet()
            df = spreadsheet["df"]
            df = df.replace(np.NaN, "")
            rows = len(df.index)-1

            cols = self.meta_data.get("columns")

            # We need to retrieve the settings for each column to figure out which is lat, lng, description, etc
            count = 0
            field_match = {}
            for each in df.columns:
                try:
                    field_match[each] = cols[count]
                except:
                    error = "We are unable to match all columns - please ensure they have all been properly matched"
                count += 1

            if "Name" not in cols or "Latitude" not in cols or "Longitude" not in cols:
                error = "Not all required fields are matched (Name, Latitude, Longitude)"
            elif rows > 1000:
                # We don't process files with more than a 1000 items
                error = "More than 1,000 items - we can not import spreadsheets of this size."
            else:
                for i, row in df.iterrows():
                    this_row = {}
                    # This CERTAINLY needs to be rewritten, I read everywhere that this looping is not ideal
                    # But I'm not sure how, so TODO
                    for column_name, content in row.iteritems():
                        meta_data = {}
                        this_field = field_match[column_name]
                        this_row[column_name] = content
                        if this_field == "Name":
                            name = content
                        elif this_field == "Latitude":
                            lat = content
                        elif this_field == "Longitude":
                            lng = content
                        else:
                            meta_data[column_name] = content

                    try:
                        geo = Point(lng, lat)
                    except:
                        geo = None

                    space = ReferenceSpace.objects.create(
                        name = name,
                        geometry = geo,
                        source = self,
                        meta_data = {"features": meta_data} if len(meta_data) else None,
                    )
        if error:
            self.meta_data["processing_error"] = error
        else:
            self.meta_data["processed"] = True
            if "processing_error" in self.meta_data:
                self.meta_data.pop("processing_error")
            if "allow_deletion_spaces" in self.meta_data:
                self.meta_data.pop("allow_deletion_spaces")

        self.save()

        return True

    def create_shapefile_plot(self):
        if not self.meta_data:
            self.meta_data = {}
        try:
            files = self.attachments.filter(Q(file__iendswith=".shp")|Q(file__iendswith=".shx")|Q(file__iendswith=".dbf")|Q(file__iendswith=".prj"))
            if files.count() < 4:
                self.meta_data["shapefile_plot_error"] = "No shapefile found! Make sure all required files are uploaded (.shp, .shx, .dbf, .prj)."
            elif files.count() > 4:
                self.meta_data["shapefile_plot_error"] = "Too many files found! Make sure one file is uploaded for all four required types (.shp, .shx, .dbf, .prj)."
            else:
                file = files.filter(file__iendswith=".shp")
                if not file:
                    self.meta_data["shapefile_plot_error"] = "No shapefile (.shp) found!"
                else:
                    file = file[0]
                    filename = settings.MEDIA_ROOT + "/" + file.file.name
                    df = geopandas.read_file(filename)
                    df = df.to_crs(epsg=3857)
                    ax = df.plot(alpha=0.5, edgecolor="k")
                    ctx.add_basemap(ax)
                    fig = ax.get_figure()
                    output = upload_directory(self, "shapefile_plot.png")
                    fig.savefig(settings.MEDIA_ROOT + "/" + output)
                    self.meta_data["shapefile_plot"] = output
                    self.meta_data["shapefile_plot_error"] = None
            self.save()
        except Exception as e:
            self.meta_data["shapefile_plot_error"] = str(e)
            self.save()

    def get_gis_layer(self):
        # Here we try to get the .shp file and load it as a gdal layer
        try:
            file = self.attachments.filter(file__iendswith=".shp")
            file = file[0]
            filename = settings.MEDIA_ROOT + "/" + file.file.name
            datasource = DataSource(filename)
            return datasource[0]
        except:
            return None

    def get_spreadsheet(self, id=None):
        # We use this to retrieve the attached spreadsheet, if there is one.
        # We return some general info (file type, the file object), and a pandas data frame

        doc = self.attachments.count()

        error = False
        error_message = None
        df = None
        extension = None
        file_type = None

        if doc == 0:
            error = True
            error_message = "No file was found. Make sure a spreadsheet file (CSV, ODS, XLS, XLSX) is uploaded."
        elif id:
            doc = self.attachments.get(pk=id)
        elif doc == 1:
            doc = self.attachments.all()[0]
        else:
            doc = self.attachments.filter(name__icontains=".final.")
            if doc.count() == 1:
                doc = doc[0]
            else:
                error = True
                error_message = "Multiple files were found. Please upload ONE file that contains '.final' in the name (example.final.xls) so that we know which file to work with"
        if doc:
            extension = doc.name
            extension = extension.split(".")
            extension = extension[-1].lower()

            options = {
                "xls": "Excel spreadsheet",
                "xlsx": "Excel spreadsheet",
                "csv": "Comma separated file",
                "ods": "OpenDocument Spreadsheet Document",
            }

            if extension in options:
                file_type = options[extension]
                try:
                    if extension == "csv":
                        df = pd.read_csv(doc.file.file)
                    else:
                        df = pd.read_excel(doc.file.file)
                except Exception as e:
                    error = True
                    error_message = "We could not fully load all relevant information. The following error ocurred: " + str(e)
            else:
                error = True
                doc = None
                file_type = "Unrecognised format"
                error_message = "This file is invalid. Make sure a spreadsheet file (CSV, ODS, XLS, XLSX) is uploaded."

        return {
            "file": doc,
            "file_type": file_type,
            "df": df,
            "error": error,
            "error_message": error_message,
            "extension": extension,
        }

    def get_color(self):
        import random
        list = ["green", "blue", "red", "orange", "brown", "navy", "teal", "purple", "pink", "maroon", "chocolate", "gold", "ivory", "snow"]
        return random.choice(list)

    def save(self, *args, **kwargs):
        if self.doi:
            try:
                url = self.doi
                if url[:4] == "http":
                    self.doi = url.rsplit("/", 1)[-1]
            except:
                pass
        if self.type_id == 40:
            try:
                # For shapefiles we check to see if this is a beginners-friendly shapefile
                # We only care about that if the record has not yet been processed
                if not self.meta_data:
                    self.meta_data = {}
                if not "processed" in self.meta_data:
                    # If the system successfully generated the preview plot (which means the GIS file is in principle okay)
                    # and the shapefile is less than 1MB and it contains less than 500 items, then we consider it beginner-friendly
                    if self.get_shapefile_plot and self.get_shapefile_size < 1024*1024 and self.get_gis_layer().num_feat < 500:
                        self.meta_data["beginner_friendly"] = True
                    elif "beginner_friendly" in self.meta_data:
                        self.meta_data.pop("beginner_friendly")
            except:
                pass
        super(LibraryItem, self).save(*args, **kwargs)

    objects = PublicActiveRecordManager()
    objects_unfiltered = models.Manager()
    objects_include_private = PrivateRecordManager()

class Video(LibraryItem):
    embed_code = models.CharField(max_length=20, null=True, blank=True)
    date = models.DateField(blank=True, null=True)
    duration = models.PositiveSmallIntegerField(null=True, blank=True, help_text="Duration in minutes")
    VIDEO_SITES = [
        ("youtube", "Youtube"),
        ("vimeo", "Vimeo"),
        ("ted", "TED"),
        ("other", "Other"),
    ]
    video_site = models.CharField(max_length=14, choices=VIDEO_SITES)
    def get_absolute_url(self):
        return reverse("multimedia:video", args=[self.id])

    def get_embed_code(self):
        url = self.url
        if not url:
            # This is for ascus only, we should fix / remove later
            url = self.file_url
        if url:
            # Thank you https://stackoverflow.com/questions/4356538/how-can-i-extract-video-id-from-youtubes-link-in-python
            # Examples:
            # - http://youtu.be/SA2iWivDJiE
            # - http://www.youtube.com/watch?v=_oPAwA_Udwc&feature=feedu
            # - http://www.youtube.com/embed/SA2iWivDJiE
            # - http://www.youtube.com/v/SA2iWivDJiE?version=3&amp;hl=en_US
            query = urlparse(url)
            if query.hostname == "youtu.be": return query.path[1:]
            if query.hostname in ("www.youtube.com", "youtube.com"):
                if query.path == "/watch": return parse_qs(query.query)["v"][0]
                if query.path[:7] == "/embed/": return query.path.split("/")[2]
                if query.path[:3] == "/v/": return query.path.split("/")[2]
                return None

    def embed(self):
        if self.video_site == "youtube":
            code = self.get_embed_code()
            return f'<iframe class="video-embed youtube-video" src="https://www.youtube.com/embed/{code}?rel=0" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>'
        elif self.url and "ted.com" in self.url:
            try:
                url = self.url
                url = url.split("/")
                url = url[-1]
                return f'<iframe class="video-embed ted-video" title="ted-player" src="https://embed.ted.com/talks/{url}" frameborder="0" allowfullscreen></iframe>'
            except:
                return "<div class='alert alert-warning'>Embedded video unavailable. <a href='" + self.url + "'>Click here to view the video</a></div>"
        elif self.video_site == "vimeo":
            return f'<iframe class="video-embed vimeo-video" title="vimeo-player" src="https://player.vimeo.com/video/{self.embed_code}" frameborder="0" allowfullscreen></iframe>'
        elif self.attachments.all():
            try:
                file = self.meta_data["video_settings"]["compiled_video"]
                file = settings.MEDIA_URL + file
            except:
                file = self.attachments.all()[0]
                file = file.file.url
            return mark_safe(f'<video src="{file}" controls preload="metadata" style="height:30vh;width:100vw;max-width:100%"></video><br><a href="{file}">Download video</a>')

    objects = PublicActiveRecordManager()
    objects_unfiltered = models.Manager()
    objects_include_private = PrivateRecordManager()

class Photo(LibraryItem):
    position = models.PositiveSmallIntegerField(null=True, blank=True, db_index=True, default=1)

    objects = PublicActiveRecordManager()
    objects_unfiltered = models.Manager()
    objects_include_private = PrivateRecordManager()

class ActivatedSpace(models.Model):
    space = models.ForeignKey("ReferenceSpace", on_delete=models.CASCADE, related_name="activated")
    part_of_project = models.ForeignKey(Project, on_delete=models.CASCADE)
    slug = models.CharField(max_length=255, db_index=True)

    def __str__(self):
        return self.space.name

    def get_absolute_url(self):
        return reverse("data:dashboard", args=[self.slug])

    def save(self, *args, **kwargs):
        self.slug = slugify(unidecode(self.space.name))
        super().save(*args, **kwargs)

    class Meta:
        unique_together = ["slug", "part_of_project"]
        ordering = ["space__name"]

class Dataset(LibraryItem):
    data_formats = models.ManyToManyField(Tag, blank=True, related_name="library_datasets", limit_choices_to={"parent_tag_id": 786})
    data_year_start = models.IntegerField(null=True, blank=True)
    data_year_end = models.IntegerField(null=True, blank=True)
    data_interval = models.CharField(max_length=50, null=True, blank=True)
    update_frequency = models.CharField(max_length=50, null=True, blank=True)
    has_api = models.BooleanField(default=True, db_index=True)
    size = models.IntegerField(null=True, blank=True, help_text="Size in MB")
    activities = models.ManyToManyField("Activity", blank=True)

    objects = PublicActiveRecordManager()
    objects_unfiltered = models.Manager()
    objects_include_private = PrivateRecordManager()

class DataPortal(LibraryItem):

    class Software(models.IntegerChoices):
        CKAN = 1, "CKAN"
        DKAN = 2, "DKAN"
        JUNAR = 3, "Junar"
        ODS = 4, "OpenDataSoft"
        SIXCMS = 5, "sixcms"
        SOCRATA = 6, "Socrata"
        TERRA = 7, "terraCatalogue"
        CUSTOM = 8, "Custom / inhouse implementation"
        OTHER = 9, "Other platform"
        ARCGIS = 10, "ArcGIS Open Data"

    software = models.IntegerField(choices=Software.choices, null=True, blank=True)
    has_api = models.BooleanField(default=True, db_index=True)

    objects = PublicActiveRecordManager()
    objects_unfiltered = models.Manager()
    objects_include_private = PrivateRecordManager()

class Course(Record):
    slug = models.CharField(max_length=255, null=True, help_text="Do NOT change this if the course is already published")
    faq = models.TextField(null=True, blank=True)
    language = models.ForeignKey(Language, on_delete=models.CASCADE, null=True, blank=True)
    projects = models.ManyToManyField(Project, blank=True)

    def save(self, *args, **kwargs):
        self.slug = slugify(unidecode(self.name))
        super().save(*args, **kwargs)

    def get_absolute_url(self):
        return reverse("education:course", args=[self.slug])

    def __str__(self):
        return self.name

    def students(self):
        return RecordRelationship.objects.filter(record_child=self, relationship_id=12)

    def recent_students(self):
        # Students who signed up in the last 90 days
        next_week = datetime.datetime.now() - datetime.timedelta(days=90)
        return RecordRelationship.objects.filter(record_child=self, relationship_id=12)

class CourseModule(Record):
    part_of_course = models.ForeignKey(Course, on_delete=models.CASCADE, related_name="modules")

    def get_absolute_url(self):
        return reverse("education:module", args=[self.part_of_course.slug, self.id])

    def __str__(self):
        return self.name

    class Meta:
        ordering = ["name"]

    # Important to note! The unfiltered objects come first, unlike other tables where 
    # the regular objects manager comes first. The reason is that we recurringly want to show
    # all modules, but we mark out those that are not yet published (not active).
    objects_unfiltered = models.Manager()
    objects = PublicActiveRecordManager()
    objects_include_private = PrivateRecordManager()

class CourseQuestion(models.Model):
    question = models.CharField(max_length=255)
    module = models.ForeignKey(CourseModule, on_delete=models.CASCADE, related_name="questions")
    answer = models.ForeignKey("CourseQuestionAnswer", on_delete=models.CASCADE, null=True, blank=True)
    position = models.PositiveSmallIntegerField(db_index=True, null=True, blank=True)

    def __str__(self):
        return self.question

    class Meta:
        ordering = ["position"]

class CourseQuestionAnswer(models.Model):
    question = models.ForeignKey(CourseQuestion, on_delete=models.CASCADE, related_name="answers")
    answer = models.CharField(max_length=255)

    def __str__(self):
        return self.answer

class CourseContent(Record):
    class Type(models.IntegerChoices):
        VIDEO = 1, "Video"
        TEXT = 2, "Text"
        EXERCISE = 3, "Exercise"

    type = models.IntegerField(choices=Type.choices, db_index=True, default=1)
    video = models.ForeignKey(Video, on_delete=models.CASCADE, null=True, blank=True)
    module = models.ForeignKey(CourseModule, on_delete=models.CASCADE, related_name="content")
    position = models.PositiveSmallIntegerField(db_index=True, null=True, blank=True)

    class Meta:
        ordering = ["position"]

class WorkActivity(models.Model):

    class WorkType(models.IntegerChoices):
        CREATE = 1, "Creating"
        UPLOAD = 2, "Uploading"
        REVIEW = 3, "Reviewing"
        CURATE = 4, "Curating"
        SHARE = 5, "Sharing"
        PARTICIPATE = 6, "Participating"
        LEARN = 7, "Learning"
        ADMIN = 8, "Administering"
        PROGRAM = 9, "Programming"
        DESIGN = 10, "Designing"
        COMMS = 11, "Communicating"

    type = models.IntegerField(choices=WorkType.choices, db_index=True)
    name = models.CharField(max_length=255)
    instructions = models.TextField(null=True, blank=True)
    default_project = models.ForeignKey(Project, on_delete=models.CASCADE, null=True, blank=True)
    points = models.PositiveSmallIntegerField(null=True, blank=True)
    url = models.URLField(null=True, blank=True, help_text="Is there a specific link a user could go to in order to work on this task? If so, put it here")

    def __str__(self):
        return self.name

    class Meta:
        verbose_name_plural = "work activities"
        ordering = ["name"]

class Work(Record):

    class WorkStatus(models.IntegerChoices):
        OPEN = 1, "Open"
        COMPLETED = 2, "Completed"
        DISCARDED = 3, "Discarded"
        ONHOLD = 4, "On Hold"
        PROGRESS = 5, "In Progress"

    class WorkPriority(models.IntegerChoices):
        LOW = 1, "Low"
        MEDIUM = 2, "Medium"
        HIGH = 3, "High"

    status = models.IntegerField(choices=WorkStatus.choices, db_index=True, default=1)
    priority = models.IntegerField(choices=WorkPriority.choices, db_index=True, default=2)
    part_of_project = models.ForeignKey(Project, on_delete=models.CASCADE, null=True, blank=True)
    workactivity = models.ForeignKey(WorkActivity, on_delete=models.CASCADE, null=True, blank=True)
    related_to = models.ForeignKey(Record, on_delete=models.CASCADE, null=True, blank=True, related_name="my_work")
    assigned_to = models.ForeignKey(People, on_delete=models.CASCADE, null=True, blank=True)
    url = models.URLField(null=True, blank=True, help_text="Is there a specific link a user could go to in order to work on this task? If so, put it here")
    last_update = models.ForeignKey(Message, on_delete=models.SET_NULL, null=True, blank=True)

    def __str__(self):
        return self.name if self.name else self.workactivity.name

    def get_status(self):
        css = {
            1: "font-weight-bold",
            2: "text-success",
            3: "text-muted",
            4: "text-muted",
            5: "text-warning",
        }
        c = css[self.status]
        return mark_safe("<span class='" + c + "'>" + self.get_status_display() + "</span>")

    class Meta:
        verbose_name_plural = "work items"

class WorkSprint(Record):

    start_date = models.DateTimeField()
    end_date = models.DateTimeField(null=True, blank=True)
    projects = models.ManyToManyField(Project, blank=True)
    work_tag = models.ForeignKey(Tag, on_delete=models.CASCADE, null=True, blank=True)

    objects = PublicActiveRecordManager()
    objects_unfiltered = models.Manager()
    objects_include_private = PrivateRecordManager()

    def get_dates(self):
        return get_date_range(self.start_date, self.end_date)

    def get_status(self):
        try:
            today = timezone.now()
            if self.end_date < today:
                return "finished"
            elif self.start_date <= today and self.end_date >= today:
                return "active"
            else:
                return "upcoming"
        except:
            return "upcoming"

    class Meta:
        ordering = ["-start_date"]

class Badge(models.Model):

    class BadgeType(models.IntegerChoices):
        BRONZE = 1, "Bronze"
        SILVER = 2, "Silver"
        GOLD = 3, "Gold"

    type = models.IntegerField(choices=BadgeType.choices, db_index=True)
    code = models.CharField(max_length=20, null=True, blank=True, db_index=True, help_text="Do not change, this is used in the code to verify if people have the right permission level")
    name = models.CharField(max_length=255)
    description = models.CharField(max_length=255)
    projects = models.ManyToManyField(Project, blank=True)
    worktype = models.ManyToManyField(WorkActivity, blank=True) 
    required_quantity = models.PositiveSmallIntegerField(null=True, blank=True)
   
    def __str__(self):
        return self.name

    class Meta:
        ordering = ["code", "type"]

#
#
#
# STAFDB TABLES
#
#
#

# The geocode scheme defines a particular standard, for instance 3166-1 or the South African postal code system
class GeocodeScheme(Record):
    url = models.URLField(null=True, blank=True)
    coverage = models.ForeignKey("ReferenceSpace", on_delete=models.SET_NULL, null=True, blank=True)
    is_comprehensive = models.BooleanField(default=True, db_index=True)
    icon = models.CharField(max_length=50, null=True, blank=True) # Web field

    class Type(models.IntegerChoices):
        SUBDIVISION = 1, "National subdivisions"
        SECTOR = 2, "Infrastructure"
        AREAS = 3, "Administrative areas"

    type = models.IntegerField(choices=Type.choices, db_index=True, default=3)

    objects = PublicActiveRecordManager()
    objects_unfiltered = models.Manager()
    objects_include_private = PrivateRecordManager()

    def __str__(self):
        return self.name

    def get_absolute_url(self):
        return reverse("staf:geocode", args=[self.id])

    class Meta:
        db_table = "stafdb_geocode_scheme"
        ordering = ["name"]

# Lists all the different levels within the system. Could be a single level (e.g. Postal Code), but it 
# could also include various levels, e.g.: Country > Province > City
# Depth should start at 0 and go up from there
class Geocode(Record):
    scheme = models.ForeignKey(GeocodeScheme, on_delete=models.CASCADE, related_name="geocodes")
    depth = models.PositiveSmallIntegerField()

    objects = PublicActiveRecordManager()
    objects_unfiltered = models.Manager()
    objects_include_private = PrivateRecordManager()

    def __str__(self):
        return self.name

    class Meta:
        db_table = "stafdb_geocode"
        ordering = ["depth", "pk"]

# The reference space, for instance the country "South Africa", the city "Cape Town", or the postal code 8000
class ReferenceSpace(Record):
    geocodes = models.ManyToManyField(Geocode, through="ReferenceSpaceGeocode")
    geometry = models.GeometryField(null=True, blank=True)
    source = models.ForeignKey(LibraryItem, on_delete=models.CASCADE, null=True, blank=True, related_name="imported_spaces")

    def __str__(self):
        return self.name

    # Let's bring back slug as a field, but make it nullable and only set when activating a space
    # TODO

    @property
    def slug(self):
        return slugify(unidecode(self.name))

    @property
    def is_city(self):
        #check = self.geocodes.filter(id=123)
        check = self.geocodes.filter(name="Urban").exists()
        return True if check else False

    @property
    def is_island(self):
        #check = self.geocodes.filter(id=123)
        check = self.geocodes.filter(name="Island").exists()
        return True if check else False

    @property
    def get_centroids(self):
        try:
            lat = self.geometry.centroid[1]
            lng = self.geometry.centroid[0]
            return [lat,lng]
        except:
            return None

    @property
    def get_lat(self):
        try:
            return self.geometry.centroid[1]
        except:
            return None

    @property
    def get_lng(self):
        try:
            return self.geometry.centroid[0]
        except:
            return None

    # So this was what we used before, but it means a db query every time we pull this field in
    # Not efficient. We now have a signal (update_referencespace_photo) that simply checks if 
    # photos are being changed and then adds it to the IMAGE field in the reference space, allowing
    # us to pull in the photo using the get_thumbnail or get_large_photo properties instead, which 
    # don't need any additional db query. This photo field needs to be phased out but I want to see
    # exactly where it lives on the site. Let's try to phase out no later than March 2021...

    @property
    def photo(self):
        from core.models import Photo
        try:
            return Photo.objects.filter(spaces=self).order_by("position")[0]
        except:
            return Photo.objects.get(pk=33476)

    @property
    def get_thumbnail(self):
        if self.image:
            return self.image.thumbnail.url
        else:
            return "/media/records/placeholder.thumbnail.png"

    @property
    def get_large_photo(self):
        if self.image:
            return self.image.large.url
        else:
            return "/media/records/placeholder.png"

    def get_completion(self):
        try:
            return self.meta_data["progress"]["completion"]
        except:
            None

    def get_counter(self):
        try:
            return self.meta_data["progress"]["counter"]
        except:
            None

    def get_document_counter(self):
        try:
            return self.meta_data["progress"]["document_counter"]
        except:
            None

    class Meta:
        db_table = "stafdb_referencespace"
        ordering = ["name"]

@receiver(post_save, sender=Photo)
def update_referencespace_photo(sender, instance, created, **kwargs):
    for space in instance.spaces.all():
        # Let's see which spaces this photo is related with - if any
        # And if it turns out that this is the first photo then we mark this as the primary image
        try:
            photo = Photo.objects.filter(spaces=space).order_by("position", "id")[0]
        except:
            photo = Photo.objects.get(pk=33476)
        space.image = photo.image
        space.save()

class ReferenceSpaceGeocode(models.Model):
    geocode = models.ForeignKey(Geocode, on_delete=models.CASCADE)
    space = models.ForeignKey(ReferenceSpace, on_delete=models.CASCADE)
    identifier = models.CharField(max_length=255, db_index=True, null=True, blank=True)

    class Meta:
        db_table = "stafdb_referencespace_geocode"

class ActivityCatalog(Record):
    url = models.URLField(null=True, blank=True)
    original_file = models.FileField(null=True, blank=True, upload_to="activity_catalogs")

    def __str__(self):
        return self.name

    class Meta:
        db_table = "stafdb_activitycatalog"
        verbose_name_plural = "activity catalogs"

class Activity(Record):
    catalog = models.ForeignKey(ActivityCatalog, on_delete=models.CASCADE)
    code = models.CharField(max_length=255, null=True, blank=True, db_index=True)
    parent = models.ForeignKey("self", on_delete=models.CASCADE, null=True, blank=True, related_name="children")
    is_separator = models.BooleanField()
    def __str__(self):
        if self.code:
            return self.code + " - " + self.name
        else:
            return self.name

    class Meta:
        db_table = "stafdb_activity"
        verbose_name_plural = "activities"

# The Flow Diagram describes a system (e.g. the Water sector) and describes the life-cycle based on 
# the processes that take place within it (e.g. Water collection > Water treatment > Use > Wastewater treatment)
class FlowDiagram(Record):
    icon = models.CharField(max_length=50, null=True, blank=True, help_text="Only include the icon name, not fa- classes --- see https://fontawesome.com/icons?d=gallery")

    def get_absolute_url(self):
        return reverse("staf:flowdiagram", args=[self.id])

    def __str__(self):
        return self.name

    class Meta:
        db_table = "stafdb_flowdiagram"

    objects = PublicActiveRecordManager()
    objects_unfiltered = models.Manager()
    objects_include_private = PrivateRecordManager()

class FlowBlocks(models.Model):
    diagram = models.ForeignKey(FlowDiagram, on_delete=models.CASCADE, related_name="blocks")
    origin = models.ForeignKey(Activity, on_delete=models.CASCADE, related_name="blocks_from")
    origin_label = models.CharField(max_length=255, null=True, blank=True)
    destination = models.ForeignKey(Activity, on_delete=models.CASCADE, related_name="blocks_to")
    destination_label = models.CharField(max_length=255, null=True, blank=True)
    description = models.TextField(null=True, blank=True)

    def __str__(self):
        return self.description if self.description else self.origin.name + " → " + self.destination.name

    def get_destination(self):
        return self.destination_label if self.destination_label else self.destination.name

    def get_origin(self):
        return self.origin_label if self.origin_label else self.origin.name

    def get_destination_slug(self):
        return slugify(self.destination_label) if self.destination_label else slugify(self.destination.name)

    def get_origin_slug(self):
        return slugify(self.origin_label) if self.origin_label else slugify(self.origin.name)

    class Meta:
        db_table = "stafdb_flowblocks"

class MaterialCatalog(Record):
    url = models.CharField(max_length=255, null=True, blank=True)
    original_file = models.FileField(null=True, blank=True, upload_to="material_catalogs")

    def __str__(self):
        return self.name

    class Meta:
        db_table = "stafdb_materialcatalog"

class MaterialType(models.IntegerChoices):
    MASS = 1, "Mass"
    VOLUME = 2, "Volume"
    COUNT = 3, "Count"
    AREA = 4, "Area"
    ENERGY = 5, "Energy"
    LENGTH = 6, "Length"
    FRACTION = 7, "Fraction"
    POWER = 8, "Power"
    OTHER = 99, "Other"

class Material(Record):
    code = models.CharField(max_length=255, null=True, blank=True, db_index=True)
    parent = models.ForeignKey("self", on_delete=models.CASCADE, null=True, blank=True, related_name="children")
    catalog = models.ForeignKey(MaterialCatalog, on_delete=models.CASCADE, blank=True, null=True, related_name="content")
    #is_separator = models.BooleanField()
    measurement_type = models.IntegerField(choices=MaterialType.choices, db_index=True, blank=True, null=True, default=1)
    icon = models.CharField(max_length=50, null=True, blank=True, help_text="Only include the icon name, not fa- classes --- see https://fontawesome.com/icons?d=gallery")

    def __str__(self):
        if self.code:
            return self.code + " - " + self.name
        else:
            return self.name

    class Meta:
        db_table = "stafdb_material"

class Unit(models.Model):
    name = models.CharField(max_length=255)
    symbol = models.CharField(max_length=255)
    description = models.TextField(null=True, blank=True)
    type = models.IntegerField(choices=MaterialType.choices, db_index=True, default=99)
    multiplication_factor = models.FloatField(null=True, blank=True, help_text="By which factor should we multiply this to get a quantity in the default unit for this type of measurement?")
    synonyms = models.JSONField(null=True, blank=True)

    def __str__(self):
        return self.name

class MaterialDemand(Record):
    material_type = models.ForeignKey(Material, on_delete=models.CASCADE)
    quantity = models.FloatField()
    unit = models.ForeignKey(Unit, on_delete=models.CASCADE)
    start_date = models.DateField()
    end_date = models.DateField()
    owner = models.ForeignKey(Record, on_delete=models.CASCADE, related_name="demand")

    def __str__(self):
        return self.material_type.name

    def type(self):
        return "supply" if self.quantity < 0 else "demand"

    def absolute_quantity(self):
        return self.quantity*-1 if self.quantity < 0 else self.quantity

    class Meta:
        ordering = ["start_date"]

class Sector(Record):
    icon = models.CharField(max_length=255, null=True, blank=True)
    photo = models.ForeignKey(Photo, on_delete=models.SET_NULL, null=True, blank=True)
    slug = models.SlugField(max_length=255)
    activities = models.ManyToManyField(Activity, db_table="stafdb_sector_activities")

    def __str__(self):
        return self.name

    class Meta:
        db_table = "stafdb_sector"

    #def spaces(self):
    #    return ReferenceSpaceType.objects.filter(processes__in=self.processes.all())
    #def datasets(self):
    #    return DatasetType.objects.filter(Q(origin_process__in=self.processes.all()) | Q(destination_process__in=self.processes.all()))

class DataArticle(Record):

    uid = models.AutoField(primary_key=True)
    record_id = models.OneToOneField(
        Record, on_delete=models.CASCADE,
        parent_link=True,
        primary_key=False,
    )

    class Completion(models.IntegerChoices):
        STUB = 1, "Stub"
        HALF = 2, "Medium article"
        COMPLETE = 3, "Complete article"

    completion = models.IntegerField(choices=Completion.choices)
    part_of_project = models.ForeignKey(Project, on_delete=models.CASCADE)
    language = models.ForeignKey(Language, on_delete=models.CASCADE, null=True, blank=True)
    slug = models.SlugField(max_length=100, unique=True, blank=True, null=True)

    objects = PublicActiveRecordManager()
    objects_unfiltered = models.Manager()
    objects_include_private = PrivateRecordManager()

    def authors(self):
        return People.objects.filter(record_history__record=self).distinct()

    def last_version(self):
        return RecordHistory.objects.filter(record=self).order_by("-id")[0]

    def save(self, *args, **kwargs):
        if not self.id:
            slug = slugify(unidecode(self.name))
            check = DataArticle.objects.filter(slug=slug).exists()
            # In the unlikely event that the slug already exists, add timestamp to it
            self.slug = slug if not check else str(int(time.time())) + "-" + slug
        super().save(*args, **kwargs)

def shapefile_directory():
    pass

class Chat(models.Model):
    channel = models.ForeignKey(Record, on_delete=models.CASCADE, related_name="chat_channel")
    people = models.ForeignKey(People, on_delete=models.CASCADE, related_name="chat")
    message = models.TextField()
    timestamp = models.DateTimeField(auto_now_add=True)

    def __str__(self):
        return "Chat from " + str(self.people)

    def last_messages(self):
        return Chat.objects.order_by("-timestamp").all()[:50]

class Notification(models.Model):
    record = models.ForeignKey(Record, on_delete=models.CASCADE, related_name="notified_people")
    people = models.ForeignKey(People, on_delete=models.CASCADE, related_name="notifications")
    is_read = models.BooleanField(db_index=True, default=False)

    def __str__(self):
        return str(self.people) + " is notified about " + str(self.record)

class EurostatDB(models.Model):
    title = models.CharField(max_length=2000)
    code = models.CharField(max_length=255)
    type = models.CharField(max_length=255)
    last_update = models.CharField(max_length=255, null=True, blank=True)
    data_start = models.CharField(max_length=255, null=True, blank=True)
    data_end = models.CharField(max_length=255, null=True, blank=True)
    url_overwrite = models.URLField(max_length=255, null=True, blank=True)
    is_reviewed = models.BooleanField(db_index=True, default=False)
    is_approved = models.BooleanField(db_index=True, null=True, blank=True)
    is_denied = models.BooleanField(db_index=True, null=True, blank=True)
    is_duplicate = models.BooleanField(db_index=True, null=True, blank=True, default=False)
    has_no_meta_data = models.BooleanField(db_index=True, null=True, blank=True)
    notes = models.TextField(null=True, blank=True)
    tags = models.ManyToManyField(Tag, blank=True)
    spaces = models.ManyToManyField(ReferenceSpace, blank=True)

    def __str__(self):
        return self.title

from django import forms
class EurostatForm(forms.ModelForm):

    def __init__(self, *args, **kwargs):
        super(EurostatForm, self).__init__(*args, **kwargs)
        self.fields["title"].strip = False

    class Meta:
        model = EurostatDB
        fields = "__all__"

class ZoteroCollection(Record):
    uid = models.AutoField(primary_key=True)
    record_id = models.OneToOneField(
        Record, on_delete=models.CASCADE,
        parent_link=True,
        primary_key=False,
    )
    api = models.CharField(max_length=255)
    zotero_id = models.CharField(max_length=255)
    part_of_project = models.ForeignKey(Project, on_delete=models.CASCADE, null=True, blank=True)

    def __str__(self):
        return self.name

class ZoteroItem(models.Model):
    title = models.CharField(max_length=255)
    key = models.CharField(max_length=255)
    library_item = models.ForeignKey(LibraryItem, on_delete=models.SET_NULL, null=True, blank=True)
    collection = models.ForeignKey(ZoteroCollection, on_delete=models.CASCADE)
    data = models.JSONField(null=True, blank=True)
    date_created = models.DateTimeField(auto_now_add=True)

    def __str__(self):
        return self.title

    def get_year(self):
        # Returns the year of publication, which is part of the date field
        # which is a string and can be formatted in any possible way, so we just 
        # look for four digits, starting with 1 or 2
        #hit = re.search(r'.*([1-2][0-9]{3})', self.data.get("date"))
        try:
            pattern = re.compile("([1-2][0-9]{3})")
            return pattern.findall(self.data.get("date"))[0]
        except:
            return None

    def import_to_library(self):
        info = self.find_match()
        if not info:
            info = LibraryItem()
        info.name = self.title
        info.author_list = self.get_authors()
        info.year = self.get_year()
        info.url = self.data.get("url")
        info.description = self.data.get("abstractNote")
        try:
            # Zotero uses camelCase so we convert that into spaces
            full_type = re.sub(r"(\w)([A-Z])", r"\1 \2", self.data.get("itemType"))
            type = LibraryItemType.objects.get(name__iexact=full_type)
            info.type = type
        except:
            info.type_id = 16 # Default to journal article if all else fails
        info.save()

        # Let's now add the tags
        if self.collection.uid == 3:
            # Adding the island tag
            info.tags.add(Tag.objects.get(id=219))

        for each in self.find_tags():
            info.tags.add(each)

        for each in self.find_spaces():
            info.spaces.add(each)

        self.library_item = info
        self.save()

    def get_authors(self):
        all = self.data.get("creators")
        text = ""
        for each in all:
            if text != "":
                text += " and "
            text += each.get("lastName", "") + ", " + each.get("firstName", "")
        return text

    def get_tags(self):
        if "tags" in self.data:
            tags = self.data["tags"]
            all = []
            for each in tags:
                all.append(each["tag"])                
            return all
        else:
            return None

    def find_match(self):
        check = LibraryItem.objects.filter(name=self.title)
        if not check and "doi" in self.data and self.data["doi"]:
            check = LibraryItem.objects.filter(doi=doi)
        if not check and "isbn" in self.data and self.data["isbn"]:
            check = LibraryItem.objects.filter(isbn=isbn)
        if check:
            return check[0]
        else:
            return None

    def find_tags(self):
        tags = Tag.objects.filter(Q(parent_tag__parent_tag_id=938)|Q(parent_tag__parent_tag__parent_tag_id=938))
        hits = []
        for each in self.get_tags():
            # We check for tags in two ways: first we see if the "tags" in the paper exist in our tag list...
            check = Tag.objects.filter(name=each)
            if check:
                hits.append(check[0])
        for each in tags:
            # And then we do a broader search in which we check all tags in our database and we see if those
            # words are used in the title/abstract...
            # Note that we add a space before the keyword because we want the entire word
            # to be found, and otherwise e.g. "Afghanistan" will also yield a match of the STAN software package
            n = " " + each.fullname
            t = self.title
            if n.lower() in t.lower():
                hits.append(each)
            elif "abstractNote" in self.data and n.lower() in self.data["abstractNote"].lower():
                hits.append(each)
        return hits

    def find_spaces(self):
        spaces = ReferenceSpace.objects.filter(geocodes=8355)
        hits = []
        for each in spaces:
            if each.name in self.title:
                hits.append(each)
            elif "abstractNote" in self.data and each.name in self.data["abstractNote"]:
                hits.append(each)
        return hits

class TimePeriod(models.Model):
    start = models.DateField(db_index=True)
    end = models.DateField(db_index=True, null=True, blank=True)
    name = models.CharField(max_length=255, db_index=True)

    def __str__(self):
        return self.name

    class Meta:
        db_table = "stafdb_timeperiod"

class Data(models.Model):
    unit = models.ForeignKey(Unit, on_delete=models.CASCADE, null=True, blank=True)
    quantity = models.FloatField(null=True, blank=True)
    material = models.ForeignKey(Material, on_delete=models.CASCADE, null=True, blank=True)
    material_name = models.CharField(max_length=500, null=True, blank=True)
    source = models.ForeignKey(LibraryItem, on_delete=models.CASCADE, related_name="data")
    origin_space = models.ForeignKey(ReferenceSpace, on_delete=models.CASCADE, null=True, blank=True, related_name="data_from_space")
    destination_space = models.ForeignKey(ReferenceSpace, on_delete=models.CASCADE, null=True, blank=True, related_name="data_to_space")
    origin = models.ForeignKey(Activity, on_delete=models.CASCADE, null=True, blank=True, related_name="data_from")
    destination = models.ForeignKey(Activity, on_delete=models.CASCADE, null=True, blank=True, related_name="data_to")
    comments = models.TextField(null=True, blank=True)
    timeframe = models.ForeignKey(TimePeriod, on_delete=models.CASCADE)
    segment_name = models.CharField(max_length=500, null=True, blank=True)

    class Meta:
        db_table = "stafdb_data"
        ordering = ["timeframe__start", "id"]

class DataViz(Record):
    uid = models.AutoField(primary_key=True)
    record_id = models.OneToOneField(
        Record, on_delete=models.CASCADE,
        parent_link=True,
        primary_key=False,
    )
    source = models.ForeignKey(LibraryItem, on_delete=models.CASCADE, null=True, blank=True, related_name="dataviz")

    def __str__(self):
        return self.name

class Milestone(Record):
    position = models.PositiveSmallIntegerField(db_index=True, help_text="Enter 0 to make this the annual summary")
    year = models.PositiveSmallIntegerField()
    projects = models.ManyToManyField(Project)

    def __str__(self):
        return self.name

    class Meta:
        ordering = ["year", "position"]

# This is the format to use from now on
# Note that there is a uid primary key, separate from the record_id
# This is must easier to have individual primary key sequences
#
# We should migrate the old stuff at some points
# See https://new.metabolismofcities.org/tasks/33488/
#
#class Dummy(Record):
#    uid = models.AutoField(primary_key=True)
#    record_id = models.OneToOneField(
#        Record, on_delete=models.CASCADE,
#        parent_link=True,
#        primary_key=False,
#    )
#    info = models.CharField(max_length=100)

class LocalBusinessDependency(models.Model):
    name = models.CharField(max_length=255)

    def __str__(self):
        return self.name

    class Meta:
        ordering = ["id"]
        verbose_name_plural = "Local Business Dependencies"

class LocalBusinessLink(models.Model):
    organization = models.ForeignKey(Organization, on_delete=models.CASCADE, null=True, blank=True, related_name='organization')
    dependence = models.ForeignKey(LocalBusinessDependency, on_delete=models.CASCADE, null=True, blank=True)
    business= models.ForeignKey(Organization, on_delete=models.CASCADE, null=True, blank=True)